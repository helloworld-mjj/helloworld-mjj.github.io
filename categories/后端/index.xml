<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>后端 on MJJ&#39;s BLog 💭</title>
        <link>https://helloworld-mjj.github.io/categories/%E5%90%8E%E7%AB%AF/</link>
        <description>Recent content in 后端 on MJJ&#39;s BLog 💭</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>MJJ</copyright>
        <lastBuildDate>Wed, 29 May 2024 17:30:58 +0800</lastBuildDate><atom:link href="https://helloworld-mjj.github.io/categories/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>手写网关文档</title>
        <link>https://helloworld-mjj.github.io/p/%E6%89%8B%E5%86%99%E7%BD%91%E5%85%B3%E6%96%87%E6%A1%A3/</link>
        <pubDate>Wed, 29 May 2024 17:30:58 +0800</pubDate>
        
        <guid>https://helloworld-mjj.github.io/p/%E6%89%8B%E5%86%99%E7%BD%91%E5%85%B3%E6%96%87%E6%A1%A3/</guid>
        <description>&lt;h2 id=&#34;网关功能&#34;&gt;网关功能
&lt;/h2&gt;&lt;p&gt;这里先梳理一下我们的网关主要的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求路由: 这是网关的最核心的功能，将前端的请求聚合到网关进行分发。&lt;/li&gt;
&lt;li&gt;熔断限流: 支持单机限流以及分布式限流，并且支持多种限流算法。为了下游服务的安全性，我们必须对部分可能出现大流量的接口进行限流，并对不可用的服务进行熔断防止服务雪崩。&lt;/li&gt;
&lt;li&gt;统一鉴权: 在网关层进行统一鉴权，让下游服务更专注于业务代码的编写。&lt;/li&gt;
&lt;li&gt;服务监控: 在网关层进行服务的监控，同样可以让下游服务专注于业务代码的编写。&lt;/li&gt;
&lt;li&gt;负载均衡: 这也是网关的一个核心功能，需要对多个相同的服务进行负载均衡，保证各个服务器可以分担压力。&lt;/li&gt;
&lt;li&gt;灰度发布: 灰度发布旨在提高服务的可用性，在发布新版本时不用停止服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目录结构&#34;&gt;目录结构
&lt;/h2&gt;&lt;h3 id=&#34;模块介绍&#34;&gt;模块介绍
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mGateway-client&lt;/code&gt;: 定义了一些注解以及用于将测试服务注册到注册中心&lt;br&gt;
&lt;code&gt;mGateway-http-server&lt;/code&gt;: 定义了一些测试类，结合client模块注册到注册中心方便进行网关测试&lt;br&gt;
&lt;code&gt;mGateway-common&lt;/code&gt;: 此模块为公共模块，定义了一些通用的类&lt;br&gt;
&lt;code&gt;mGateway-config-center&lt;/code&gt;: 定义了配置中心的接口及其基于SPI的实现&lt;br&gt;
&lt;code&gt;mGateway-register-center&lt;/code&gt;: 定义了注册中心的接口及其基于SPI的实现&lt;br&gt;
&lt;code&gt;mGateway-corn&lt;/code&gt;: 此模块为核心模块，包括netty服务器和客户端、过滤器链、上下文的配置等&lt;/p&gt;
&lt;h3 id=&#34;核心模块目录介绍&#34;&gt;核心模块目录介绍
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;BootStrap&lt;/code&gt;: 网关的启动类，启动网关并加载配置和注册订阅服务&lt;br&gt;
&lt;code&gt;Config&lt;/code&gt;: 网关的配置信息，此类中配置了默认值，网关启动时会从classpath下的&lt;code&gt;gateway.properties&lt;/code&gt;文件加载配置&lt;br&gt;
&lt;code&gt;ConfigLoader&lt;/code&gt;: 此类定义了加载配置的具体方法和步骤&lt;br&gt;
&lt;code&gt;Container&lt;/code&gt;: 此类实现了&lt;code&gt;lifeCycle&lt;/code&gt;接口，用于管理netty的组件，包括它们的初始化、启动、终止&lt;br&gt;
&lt;code&gt;netty&lt;/code&gt;: 这个包中定义了一些netty的一些组件，包括netty服务器、netty客户端、Disruptor事件处理、Http请求处理等&lt;br&gt;
&lt;code&gt;helper&lt;/code&gt;: 这个包中定义了解析request和response的组件，以及异步Http请求客户端&lt;br&gt;
&lt;code&gt;request&lt;/code&gt;: 这个包中定义了网关的请求类&lt;br&gt;
&lt;code&gt;response&lt;/code&gt;: 这个包中定义了网关的响应类&lt;br&gt;
&lt;code&gt;disruptor&lt;/code&gt;: 这个包中配置了Disruptor框架&lt;br&gt;
&lt;code&gt;filter&lt;/code&gt;: 这个包中定义了一系列的过滤器，使用SPI的方式进行加载，包括鉴权过滤器、灰度发布过滤器、限流过滤器、负载均衡过滤器、监控过滤器、路由过滤器等&lt;br&gt;
&lt;code&gt;context&lt;/code&gt;: 这个包中定义了网关的上下文对象，所谓上下文就是贯穿了整个网关，包含了解析后的请求和响应&lt;br&gt;
&lt;code&gt;cache&lt;/code&gt;: 这个包中定义了网关的缓存，主要是Caffine实现的本地缓存&lt;/p&gt;
&lt;h3 id=&#34;公共模块目录介绍&#34;&gt;公共模块目录介绍
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;config&lt;/code&gt;: 此包定义了网关的一些配置信息，比如服务定义实体和服务实体，以及路由规则实体和服务映射关系&lt;br&gt;
&lt;code&gt;constant&lt;/code&gt;: 此包定义了一些常量&lt;br&gt;
&lt;code&gt;enums&lt;/code&gt;: 此包定义了一些枚举类型&lt;br&gt;
&lt;code&gt;exception&lt;/code&gt;: 此包定义了网关中的异常类&lt;br&gt;
&lt;code&gt;utils&lt;/code&gt;: 此包定义了一些工具类，包括对象转换、JWT工具、IP解析等&lt;/p&gt;
&lt;h2 id=&#34;功能实现&#34;&gt;功能实现
&lt;/h2&gt;&lt;h3 id=&#34;服务器实现&#34;&gt;服务器实现
&lt;/h3&gt;&lt;p&gt;我们做为网关首先需要可以接收网络请求，这里使用Netty构建服务器，主要得益于Netty的Reactor模型，netty服务器的实现主要在&lt;code&gt;com.gateway.core.netty.NettyHttpServer&lt;/code&gt;这个类中。&lt;br&gt;
主要思路是使用&lt;code&gt;BossEventLoopGroup&lt;/code&gt;来管理网络连接，而&lt;code&gt;WorkerEventLoopGroup&lt;/code&gt;来管理网络I/O，&lt;code&gt;WorkerEventLoopGroup&lt;/code&gt;接收到I/O请求作为生产者生产一个事件交给&lt;code&gt;Disruptor&lt;/code&gt;，而使用了一组消费者线程池来处理&lt;code&gt;Disruptor&lt;/code&gt;中的事件。&lt;/p&gt;
&lt;h3 id=&#34;客户端实现&#34;&gt;客户端实现
&lt;/h3&gt;&lt;p&gt;这里我们基于异步Http客户端&lt;code&gt;DefaultAsycHttpClient&lt;/code&gt;结合Netty的EventLoopGroup构建了一个用来转发请求的异步Http客户端，其主要实现在&lt;code&gt;com.gateway.core.netty.NettyHttpClient&lt;/code&gt;这个类中。&lt;/p&gt;
&lt;h3 id=&#34;请求上下文实现&#34;&gt;请求上下文实现
&lt;/h3&gt;&lt;p&gt;这里我们首先定义了&lt;code&gt;IContext&lt;/code&gt;接口定义了上下文规范。&lt;br&gt;
&lt;code&gt;BaseContext&lt;/code&gt;为上下文的基本实现，定义了上下文的协议、状态、异常、上下文相关参数、以及对应的netty上下文。&lt;br&gt;
&lt;code&gt;GateContext&lt;/code&gt;为网关上下文的实现，继承了&lt;code&gt;BaseContext&lt;/code&gt;，并且封装了request和response以及请求规则和相关参数。&lt;/p&gt;
&lt;h3 id=&#34;过滤器链实现&#34;&gt;过滤器链实现
&lt;/h3&gt;&lt;p&gt;所有的过滤器都需要实现&lt;code&gt;Filter&lt;/code&gt;接口，启动时会以SPI的方式加载这些过滤器，只需要实现&lt;code&gt;Filter&lt;/code&gt;这个接口就可以添加自定义的过滤器。&lt;br&gt;
每次收到请求时我们都需要一个过滤器链来处理请求，这个过滤器链是根据&lt;code&gt;Rule&lt;/code&gt;请求规则构建的，这里为了避免重复对同一种请求重复构建过滤器链，我们对过滤器链添加了缓存。同时我们需要一个过滤器链工厂来构建过滤器链，这个工厂不需要重复构建多个，因为这个工厂可以生产多个过滤器链，所以引入工厂模式和单例模式构建这个过滤器工厂用来生产过滤器链。&lt;br&gt;
实际上我们的网关的核心功能也就是一些过滤器的集合。&lt;/p&gt;
&lt;h4 id=&#34;鉴权过滤器&#34;&gt;鉴权过滤器
&lt;/h4&gt;&lt;p&gt;使用JWT鉴权&lt;/p&gt;
&lt;h4 id=&#34;限流过滤器&#34;&gt;限流过滤器
&lt;/h4&gt;&lt;p&gt;我们的网关支持分布式限流与本地限流。&lt;br&gt;
首先描述一下它们两个不同的使用场景，本地限流一般适用于单机的网关，根据下游服务的负载能力进行限流，单机网关使用分布式限流的话反倒会增加网络I/O，影响性能。而为了我们的网关支持高并发和高可用，我们网关必须支持集群，然而当集群模式下，每个网关都会聚合一部分请求，它们最终都会将相同的请求路由到同一个下游服务，最终下游服务收到的流量就是这些网关加起来的流量，这时候就需要使用分布式限流了，分布式限流可以保证我们网关转发到下游的服务流量总数一定。而集群模式下也未尝不可用本地限流，如果每个网关所聚合的请求数量相同时，我们可以让每个网关限流一部分，最后加起来也就是总的流量。&lt;br&gt;
我们基于Redis实现了以下几种分布式限流：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;固定时间窗口限流&lt;br&gt;
固定时间窗口限流实际上也叫计数器限流，就是统计每一秒的请求数是否超过限制。&lt;br&gt;
我们使用的是Redis的原子自增指令来实现了计数器限流。
然而此算法有很大的缺陷，如果是根据每秒请求数限流100，设想一下第1秒进入了100，第2秒也进入了100，但是，如果0~0.5秒进入了10，0.5~1秒进入了90，1~1.5秒进入90，1.5到2秒进入了10，这样总体看来第一秒还是100，第2秒还是100，但是0.5~1.5秒也算是一秒，这一秒之内出现了180个请求，已经超出了限流的阈值，这就是这个算法的一个很大的缺陷，改善方法也就是使用滑动时间窗口算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑动时间窗口限流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;令牌桶限流&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;负载均衡过滤器&#34;&gt;负载均衡过滤器
&lt;/h4&gt;&lt;p&gt;支持随机负载、轮询、加权轮询&lt;/p&gt;
&lt;h4 id=&#34;监控过滤器&#34;&gt;监控过滤器
&lt;/h4&gt;&lt;p&gt;使用prompt进行监控&lt;/p&gt;
&lt;h4 id=&#34;灰度发布过滤器&#34;&gt;灰度发布过滤器
&lt;/h4&gt;&lt;h4 id=&#34;路由过滤器&#34;&gt;路由过滤器
&lt;/h4&gt;&lt;p&gt;使用Hystrix进行熔断机制&lt;/p&gt;
&lt;p&gt;——更多细节正在梳理中&amp;hellip;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>微服务网关对比</title>
        <link>https://helloworld-mjj.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Sat, 25 May 2024 17:30:58 +0800</pubDate>
        
        <guid>https://helloworld-mjj.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94/</guid>
        <description>&lt;h2 id=&#34;api网关回顾&#34;&gt;API网关回顾
&lt;/h2&gt;&lt;h3 id=&#34;主要功能&#34;&gt;主要功能
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;路由转发：通过路由功能将请求转发到目标服务。&lt;/li&gt;
&lt;li&gt;负载均衡：多个服务之间的负载均衡。&lt;/li&gt;
&lt;li&gt;统一鉴权：对用户的身份进行统一的验证。&lt;/li&gt;
&lt;li&gt;协议转换：通过协议转换整合REST、AMQP、RPC等不同的协议。&lt;/li&gt;
&lt;li&gt;指标监控：网关对发送到服务的请求进行监控。&lt;/li&gt;
&lt;li&gt;限流熔断：在网关层面对请求进行限流，并且当服务发生故障时有响应的处理策略，使用户体验良好。&lt;/li&gt;
&lt;li&gt;黑白名单：过滤请求，拦截异常的请求信息。&lt;/li&gt;
&lt;li&gt;灰度发布：可以在多个部署下实现灰度发布。&lt;/li&gt;
&lt;li&gt;流量染色：可以在进出流量时抓住时机。
20：微服务网管作为自己的日志收集和收集器，对服务URL粒度的日志请求和响应信息就进行拦截。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常见的api网关&#34;&gt;常见的API网关
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;Zuul&lt;/li&gt;
&lt;li&gt;SpringCloud Gateway&lt;/li&gt;
&lt;li&gt;Kong&lt;/li&gt;
&lt;li&gt;OpenRestry&lt;/li&gt;
&lt;li&gt;Traefik&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
